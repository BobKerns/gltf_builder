"""
This type stub file was generated by pyright.
"""

import base64
import copy
import json
import mimetypes
import struct
import warnings
from dataclasses import _is_dataclass_instance, dataclass, field, fields
from datetime import date, datetime
from enum import Enum
from pathlib import Path
from shutil import copyfile
from typing import Any, Callable, Dict, List, Optional, Tuple, Type, Union
from urllib.parse import unquote
from dataclasses_json import dataclass_json as dataclass_json
from dataclasses_json.core import _ExtendedEncoder as JsonEncoder, _decode_dataclass

"""
pygltflib : A Python library for reading, writing and handling GLTF files.


Copyright (c) 2018,2024 Luke Miller

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
__version__ = ...
ANIM_LINEAR = ...
ANIM_STEP = ...
ANIM_CALMULLROMSPLINE = ...
ANIM_CUBICSPLINE = ...
SCALAR = ...
VEC2 = ...
VEC3 = ...
VEC4 = ...
MAT2 = ...
MAT3 = ...
MAT4 = ...
BYTE = ...
UNSIGNED_BYTE = ...
SHORT = ...
UNSIGNED_SHORT = ...
UNSIGNED_INT = ...
FLOAT = ...
COMPONENT_TYPES = ...
ACCESSOR_SPARSE_INDICES_COMPONENT_TYPES = ...
POINTS = ...
LINES = ...
LINE_LOOP = ...
LINE_STRIP = ...
TRIANGLES = ...
TRIANGLE_STRIP = ...
TRIANGLE_FAN = ...
MESH_PRIMITIVE_MODES = ...
ARRAY_BUFFER = ...
ELEMENT_ARRAY_BUFFER = ...
BUFFERVIEW_TARGETS = ...
TRANSLATION = ...
ROTATION = ...
SCALE = ...
WEIGHTS = ...
ANIMATION_CHANNEL_TARGET_PATHS = ...
POSITION = ...
NORMAL = ...
TANGENT = ...
TEXCOORD_0 = ...
TEXCOORD_1 = ...
COLOR_0 = ...
JOINTS_0 = ...
WEIGHTS_0 = ...
CLAMP_TO_EDGE = ...
MIRRORED_REPEAT = ...
REPEAT = ...
WRAPPING_MODES = ...
IMAGEJPEG = ...
IMAGEPNG = ...
IMAGE_MIMETYPES = ...
NEAREST = ...
LINEAR = ...
NEAREST_MIPMAP_NEAREST = ...
LINEAR_MIPMAP_NEAREST = ...
NEAREST_MIPMAP_LINEAR = ...
LINEAR_MIPMAP_LINEAR = ...
MAGNIFICATION_FILTERS = ...
MINIFICATION_FILTERS = ...
PERSPECTIVE = ...
ORTHOGRAPHIC = ...
CAMERA_TYPES = ...
BLEND = ...
MASK = ...
OPAQUE = ...
MATERIAL_ALPHAMODES = ...
JSON = ...
BIN = ...
MAGIC = ...
GLTF_VERSION = ...
GLTF_MIN_VERSION = ...
GLTF_MAX_VERSION = ...
DATA_URI_HEADER = ...
class BufferFormat(Enum):
    DATAURI = ...
    BINARYBLOB = ...
    BINFILE = ...


class ImageFormat(Enum):
    DATAURI = ...
    FILE = ...
    BUFFERVIEW = ...


class LetterCase(Enum):
    CAMEL = ...
    KEBAB = ...
    SNAKE = ...


def delete_empty_keys(dictionary):
    """
    Delete keys with the value ``None`` in a dictionary, recursively.

    This alters the input so you may wish to ``copy`` the dict first.

    Courtesy Chris Morgan and modified from:
    https://stackoverflow.com/questions/4255400/exclude-empty-null-values-from-json-serialization
    """
    ...

def json_serial(obj): # -> str:
    """JSON serializer for objects not serializable by default json code"""
    ...

def gltf_asdict(obj, *, dict_factory=...): # -> dict[str, Any] | dict[Any, Any] | tuple[Any, ...] | list[Any]:
    ...

@dataclass_json
@dataclass
class Property:
    extensions: Optional[Dict[str, Any]] = ...
    extras: Optional[Dict[str, Any]] = ...


@dataclass_json
@dataclass
class Asset(Property):
    generator: Optional[str] = ...
    copyright: Optional[str] = ...
    version: str = ...
    minVersion: Optional[str] = ...


class Attributes:
    def __init__(self, POSITION=..., NORMAL=..., TANGENT=..., TEXCOORD_0=..., TEXCOORD_1=..., COLOR_0: int = ..., JOINTS_0: int = ..., WEIGHTS_0=..., *args, **kwargs) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def to_json(self, *args, **kwargs): # -> str:
        ...
    
    @staticmethod
    def from_json(): # -> None:
        ...
    


@dataclass_json
@dataclass
class Primitive(Property):
    attributes: Attributes = ...
    indices: Optional[int] = ...
    mode: Optional[int] = ...
    material: Optional[int] = ...
    targets: Optional[List[Attributes]] = ...


@dataclass_json
@dataclass
class Mesh(Property):
    primitives: List[Primitive] = ...
    weights: Optional[List[float]] = ...
    name: Optional[str] = ...


@dataclass_json
@dataclass
class AccessorSparseIndices(Property):
    bufferView: int = ...
    byteOffset: Optional[int] = ...
    componentType: int = ...


@dataclass_json
@dataclass
class AccessorSparseValues(Property):
    bufferView: int = ...
    byteOffset: Optional[int] = ...


@dataclass_json
@dataclass
class Sparse(Property):
    count: int = ...
    indices: AccessorSparseIndices = ...
    values: AccessorSparseValues = ...


@dataclass_json
@dataclass
class Accessor(Property):
    bufferView: Optional[int] = ...
    byteOffset: Optional[int] = ...
    componentType: int = ...
    normalized: Optional[bool] = ...
    count: int = ...
    type: str = ...
    sparse: Optional[Sparse] = ...
    max: Optional[List[float]] = ...
    min: Optional[List[float]] = ...
    name: Optional[str] = ...


@dataclass_json
@dataclass
class BufferView(Property):
    buffer: int = ...
    byteOffset: Optional[int] = ...
    byteLength: int = ...
    byteStride: Optional[int] = ...
    target: Optional[int] = ...
    name: Optional[str] = ...


@dataclass_json
@dataclass
class Buffer(Property):
    uri: Optional[str] = ...
    byteLength: int = ...


@dataclass_json
@dataclass
class Perspective(Property):
    aspectRatio: Optional[float] = ...
    yfov: float = ...
    zfar: Optional[float] = ...
    znear: float = ...


@dataclass_json
@dataclass
class Orthographic(Property):
    xmag: float = ...
    ymag: float = ...
    zfar: float = ...
    znear: float = ...


@dataclass_json
@dataclass
class Camera(Property):
    perspective: Optional[Perspective] = ...
    orthographic: Optional[Orthographic] = ...
    type: str = ...
    name: Optional[str] = ...


@dataclass_json
@dataclass
class TextureInfo(Property):
    index: int = ...
    texCoord: Optional[int] = ...


@dataclass_json
@dataclass
class OcclusionTextureInfo(Property):
    index: Optional[int] = ...
    texCoord: Optional[int] = ...
    strength: Optional[float] = ...


@dataclass_json
@dataclass
class NormalMaterialTexture(Property):
    index: Optional[int] = ...
    texCoord: Optional[int] = ...
    scale: Optional[float] = ...


@dataclass_json
@dataclass
class PbrMetallicRoughness(Property):
    baseColorFactor: Optional[List[float]] = ...
    metallicFactor: Optional[float] = ...
    roughnessFactor: Optional[float] = ...
    baseColorTexture: Optional[TextureInfo] = ...
    metallicRoughnessTexture: Optional[TextureInfo] = ...


@dataclass_json
@dataclass
class Material(Property):
    pbrMetallicRoughness: Optional[PbrMetallicRoughness] = ...
    normalTexture: Optional[NormalMaterialTexture] = ...
    occlusionTexture: Optional[OcclusionTextureInfo] = ...
    emissiveFactor: Optional[List[float]] = ...
    emissiveTexture: Optional[TextureInfo] = ...
    alphaMode: Optional[str] = ...
    alphaCutoff: Optional[float] = ...
    doubleSided: Optional[bool] = ...
    name: Optional[str] = ...


@dataclass_json
@dataclass
class Sampler(Property):
    """
    Samplers are stored in the samplers array of the asset.
    Each sampler specifies filter and wrapping options corresponding to the GL types
    """
    input: Optional[int] = ...
    interpolation: Optional[str] = ...
    output: Optional[int] = ...
    magFilter: Optional[int] = ...
    minFilter: Optional[int] = ...
    wrapS: Optional[int] = ...
    wrapT: Optional[int] = ...


@dataclass_json
@dataclass
class Node(Property):
    mesh: Optional[int] = ...
    skin: Optional[int] = ...
    rotation: Optional[List[float]] = ...
    translation: Optional[List[float]] = ...
    scale: Optional[List[float]] = ...
    children: Optional[List[int]] = ...
    matrix: Optional[List[float]] = ...
    camera: Optional[int] = ...
    name: Optional[str] = ...


@dataclass_json
@dataclass
class Skin(Property):
    inverseBindMatrices: Optional[int] = ...
    skeleton: Optional[int] = ...
    joints: Optional[List[int]] = ...
    name: Optional[str] = ...


@dataclass_json
@dataclass
class Scene(Property):
    name: Optional[str] = ...
    nodes: Optional[List[int]] = ...


@dataclass_json
@dataclass
class Texture(Property):
    sampler: Optional[int] = ...
    source: Optional[int] = ...
    name: Optional[str] = ...


@dataclass_json
@dataclass
class Image(Property):
    uri: str = ...
    mimeType: str = ...
    bufferView: int = ...
    name: Optional[str] = ...


@dataclass_json
@dataclass
class AnimationChannelTarget(Property):
    node: Optional[int] = ...
    path: str = ...


@dataclass_json
@dataclass
class AnimationSampler(Property):
    input: int = ...
    interpolation: Optional[str] = ...
    output: int = ...


@dataclass_json
@dataclass
class AnimationChannel(Property):
    sampler: int = ...
    target: AnimationChannelTarget = ...


@dataclass_json
@dataclass
class Animation(Property):
    name: Optional[str] = ...
    channels: List[AnimationChannel] = ...
    samplers: List[AnimationSampler] = ...


@dataclass
class GLTF2(Property):
    accessors: List[Accessor] = ...
    animations: List[Animation] = ...
    asset: Asset = ...
    bufferViews: List[BufferView] = ...
    buffers: List[Buffer] = ...
    cameras: List[Camera] = ...
    extensionsUsed: List[str] = ...
    extensionsRequired: List[str] = ...
    images: List[Image] = ...
    materials: List[Material] = ...
    meshes: List[Mesh] = ...
    nodes: List[Node] = ...
    samplers: List[Sampler] = ...
    scene: int = ...
    scenes: List[Scene] = ...
    skins: List[Skin] = ...
    textures: List[Texture] = ...
    def binary_blob(self): # -> Any | None:
        """ Get the binary blob associated with glb files if available

            Returns
                (bytes): binary data
        """
        ...
    
    def set_binary_blob(self, blob): # -> None:
        ...
    
    def destroy_binary_blob(self): # -> None:
        ...
    
    def set_min_alignment(self, min_alignment: Optional[int]) -> None:
        """Set the minimum alignment for glb chunks.

        A larger alignment may still be used if necessary.
        Only power-of-two alignments are supported.
        """
        ...
    
    def required_alignment(self) -> int:
        """
        Get the required alignment for glb chunks.

        By default this is 4, unless a larger alignment is requested or
        required by an extension.

        Returns
            required_alignment (int)
        """
        ...
    
    def load_file_uri(self, uri): # -> bytes:
        """
        Loads a file pointed to by a uri
        """
        ...
    
    @staticmethod
    def decode_data_uri(uri): # -> bytes:
        """
        Decodes the binary portion of a data uri.
        """
        ...
    
    def identify_uri(self, uri): # -> Literal[BufferFormat.BINARYBLOB, BufferFormat.DATAURI, BufferFormat.BINFILE] | None:
        """
        Identify the format of the requested buffer. File, data or binary blob.

        Returns
            buffer_type (str)
        """
        ...
    
    def get_data_from_buffer_uri(self, uri): # -> bytes | Any | None:
        """
        No matter how the buffer data is stored (the uri may be a long string, a file name or imply
        a binary blob), strip off any headers and do any conversions are return a universal binary
        blob for manipulation.
        """
        ...
    
    def remove_bufferView(self, buffer_view_id): # -> BufferView:
        """
        Remove a bufferView and update all the bufferView pointers in the GLTF object
        """
        ...
    
    def remove_data_from_buffer(self, byteOffset, byteLength): # -> None:
        ...
    
    def export_datauri_as_image_file(self, data_uri, name, destination, override=..., index=...): # -> str | None:
        """ convert data uri to image file
            If destination is full path and file name, use that.
            If destination is just a directory, use the name of the data_uri
        """
        ...
    
    def export_fileuri_as_image_file(self, file_uri, destination, override=...): # -> None:
        """ Export file uri as another image file (ie copy out of GLTF into own location) """
        ...
    
    def export_image(self, image_index, destination=..., override=...): # -> str | None:
        """ Directly export an image to a file without affecting GLTF """
        ...
    
    def export_image_to_file(self, image_index, destination_path=..., override=...): # -> str | None:
        """
        Used primarily by convert_images. To export images consider using GLTF2.export_image

        image_index (int): Image index
        destination_path (str|Path): Path where to save images. Images will also be loaded from this path if needed.
        override (bool): Only save image if it does not already exist
        """
        ...
    
    def convert_images(self, image_format, path=..., override=...): # -> None:
        """
        GLTF files can store the image data in three different formats: In the buffers, as a data
        uri string and as external images files. This converts the images between the formats.

        image_format (ImageFormat.ENUM): Destination format to convert images
        path (str|Path): Path to the directory to use for loading or saving images
        override (bool): Override an image file if it already exists and is about to be replaced

        """
        ...
    
    def convert_buffers(self, buffer_format, override=...): # -> None:
        """
        GLTF files can store the buffer data in three different formats: As a binary blob ready for glb, as a data
        uri string and as external bin files. This converts the buffers between the formats.

        buffer_format (BufferFormat.ENUM)
        override (bool): Override a bin file if it already exists and is about to be replaced
        """
        ...
    
    def to_json(self, *, skipkeys: bool = ..., ensure_ascii: bool = ..., check_circular: bool = ..., allow_nan: bool = ..., indent: Optional[Union[int, str]] = ..., separators: Tuple[str, str] = ..., default: Callable = ..., sort_keys: bool = ..., **kw) -> str:
        """
        to_json and from_json from dataclasses_json
        courtesy https://github.com/lidatong/dataclasses-json
        """
        ...
    
    @classmethod
    def from_json(cls: Type[GLTF2], s: str, *, parse_float=..., parse_int=..., parse_constant=..., infer_missing=..., **kw) -> GLTF2:
        ...
    
    def gltf_to_json(self, separators=..., indent=...) -> str:
        ...
    
    @staticmethod
    def get_bin_name_from_path(path: Path): # -> str:
        """ remove an extension and path and return a bin filename (sans path) """
        ...
    
    def save_json(self, fname): # -> Literal[True]:
        ...
    
    def buffers_to_binary_blob(self): # -> bytearray:
        """ Flatten all buffers into a single buffer """
        ...
    
    def save_to_bytes(self): # -> list[Any]:
        ...
    
    def save_binary(self, fname): # -> bool:
        ...
    
    def save(self, fname, asset=...): # -> bool:
        ...
    
    @classmethod
    def gltf_from_json(cls, json_data): # -> GLTF2:
        ...
    
    @classmethod
    def load_json(cls, fname): # -> GLTF2:
        ...
    
    @classmethod
    def load_from_bytes(cls, data): # -> GLTF2 | None:
        ...
    
    @classmethod
    def load_binary(cls, fname): # -> GLTF2 | None:
        ...
    
    @classmethod
    def load_binary_from_file_object(cls, f): # -> GLTF2 | None:
        ...
    
    @classmethod
    def load(cls, fname): # -> GLTF2 | None:
        ...
    


def main(): # -> None:
    ...

if __name__ == "__main__":
    ...
